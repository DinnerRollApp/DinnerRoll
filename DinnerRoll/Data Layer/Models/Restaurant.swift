//
//  Restaurant.swift
//  DinnerRoll
//
//  Created by Michael Hulet on 9/26/17.
//  Copyright Â© 2017 Michael Hulet. All rights reserved.
//

import Foundation
import MapKit

class Restaurant: NSObject, MKAnnotation, AutoCodable{
    let id: String
    let name: String
    // sourcery:codingName = "twitter"
    let twitterUsername: String?
    let phone: String?
    let address: String?
    let crossStreet: String?
    let city: String?
    let state: String?
    let postalCode: String?
    let country: String?
    let location: CLLocationCoordinate2D
    let categories: [Category]
    let verified: Bool
    let isOpen: Bool?
    let price: Int?
    let rating: Double?
    // sourcery:excludeDecoding
    lazy private(set) var primaryCategory: Category? = {
        return categories.first(where: { (category: Category) -> Bool in
            return category.isPrimary(for: self)
        })
    }()

    enum CodingKeys: String, CodingKey{
        // These are extra keys that will be needed to properly decode all fields/containers
        case contact
        case hours
        case tier
        // The rest are generated by Sourcery
// sourcery:inline:Restaurant.CodingKeys.AutoCodable
        case id 
        case name 
        case twitterUsername = "twitter"
        case phone 
        case address 
        case crossStreet 
        case city 
        case state 
        case postalCode 
        case country 
        case location 
        case categories 
        case verified 
        case isOpen 
        case price 
        case rating 
        case primaryCategory 
// sourcery:end
    }

    required init(from decoder: Decoder) throws {
        let topContainer = try decoder.container(keyedBy: CodingKeys.self)
        id = try topContainer.decode(String.self, forKey: .id)
        name = try topContainer.decode(String.self, forKey: .name)
        location = try topContainer.decode(CLLocationCoordinate2D.self, forKey: .location)
        categories = try topContainer.decode([Category].self, forKey: .categories)
        verified = try topContainer.decodeIfPresent(Bool.self, forKey: .verified) ?? false
        rating = try topContainer.decodeIfPresent(Double.self, forKey: .rating)

        let locationContainer = try topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .location)

        address = try locationContainer.decodeIfPresent(String.self, forKey: .address)
        crossStreet = try locationContainer.decodeIfPresent(String.self, forKey: .crossStreet)
        city = try locationContainer.decodeIfPresent(String.self, forKey: .city)
        state = try locationContainer.decodeIfPresent(String.self, forKey: .state)
        postalCode = try locationContainer.decodeIfPresent(String.self, forKey: .postalCode)
        country = try locationContainer.decodeIfPresent(String.self, forKey: .country)

        if topContainer.contains(.contact){
            let contactContainer = try topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .contact)

            twitterUsername = try contactContainer.decodeIfPresent(String.self, forKey: .twitterUsername)
            phone = try contactContainer.decodeIfPresent(String.self, forKey: .phone)
        }
        else{
            twitterUsername = nil
            phone = nil
        }

        if topContainer.contains(.hours){
            let hoursContainer = try topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .hours)
            isOpen = try hoursContainer.decodeIfPresent(Bool.self, forKey: .isOpen)
        }
        else{
            isOpen = nil
        }

        if topContainer.contains(.price){
            let priceContainer = try topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .price)
            price = try priceContainer.decodeIfPresent(Int.self, forKey: .tier)
        }
        else{
            price = nil
        }

        super.init()
    }

    func encode(to encoder: Encoder) throws -> Void{
        var topContainer = encoder.container(keyedBy: CodingKeys.self)
        try topContainer.encode(id, forKey: .id)
        try topContainer.encode(name, forKey: .name)
        try topContainer.encode(location, forKey: .location)
        try topContainer.encode(verified, forKey: .verified)
        try topContainer.encode(categories, forKey: .categories)
        try topContainer.encodeIfPresent(primaryCategory, forKey: .primaryCategory)
        try topContainer.encodeIfPresent(rating, forKey: .rating)

        var locationContainer = topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .location)

        try locationContainer.encodeIfPresent(address, forKey: .address)
        try locationContainer.encodeIfPresent(crossStreet, forKey: .crossStreet)
        try locationContainer.encodeIfPresent(city, forKey: .city)
        try locationContainer.encodeIfPresent(state, forKey: .state)
        try locationContainer.encodeIfPresent(postalCode, forKey: .postalCode)
        try locationContainer.encodeIfPresent(country, forKey: .country)

        var contactContainer = topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .contact)

        try contactContainer.encodeIfPresent(twitterUsername, forKey: .twitterUsername)
        try contactContainer.encodeIfPresent(phone, forKey: .phone)


        var hoursContainer = topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .hours)
        try hoursContainer.encodeIfPresent(isOpen, forKey: .isOpen)

        var priceContainer = topContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .price)
        try priceContainer.encodeIfPresent(price, forKey: .tier)
    }

    var coordinate: CLLocationCoordinate2D{
        get{
            return location
        }
    }
    var title: String?{
        get{
            return name
        }
    }
    var subtitle: String?{
        get{
            return address
        }
    }
 }

extension CLLocationCoordinate2D: Codable{
    enum CodingKeys: String, CodingKey{
        case latitude = "lat"
        case longitude = "lng"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.init(latitude: try container.decode(Double.self, forKey: .latitude), longitude: try container.decode(Double.self, forKey: .longitude))
    }

    public func encode(to encoder: Encoder) throws -> Void{
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(latitude, forKey: .latitude)
        try container.encode(longitude, forKey: .longitude)
    }
}
